// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"fmt"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/terraform-provider-iosxe/internal/provider/helpers"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type EVPNInstance struct {
	Device                                                                                  types.String `tfsdk:"device"`
	Id                                                                                      types.String `tfsdk:"id"`
	EvpnInstanceNum                                                                         types.Int64  `tfsdk:"evpn_instance_num"`
	EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceIngressCaseIngress types.Bool   `tfsdk:"vlan_based_replication_type_ingress"`
	EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticCaseStatic   types.Bool   `tfsdk:"vlan_based_replication_type_static"`
	EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticP2mpP2mp     types.Bool   `tfsdk:"vlan_based_replication_type_p2mp"`
	EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticMp2mpMp2mp   types.Bool   `tfsdk:"vlan_based_replication_type_mp2mp"`
	EvpnServiceTypeVlanBasedVlanBasedEncapsulation                                          types.String `tfsdk:"vlan_based_encapsulation"`
	EvpnServiceTypeVlanBasedVlanBasedAutoRouteTarget_contAutoRouteTargetBoolean             types.Bool   `tfsdk:"vlan_based_auto_route_target"`
	EvpnServiceTypeVlanBasedVlanBasedRdRdValue                                              types.String `tfsdk:"vlan_based_rd"`
	EvpnServiceTypeVlanBasedVlanBasedRouteTargetRtValue                                     types.String `tfsdk:"vlan_based_route_target"`
	EvpnServiceTypeVlanBasedVlanBasedRouteTargetBothRtValue                                 types.String `tfsdk:"vlan_based_route_target_both"`
	EvpnServiceTypeVlanBasedVlanBasedRouteTargetImportRtValue                               types.String `tfsdk:"vlan_based_route_target_import"`
	EvpnServiceTypeVlanBasedVlanBasedRouteTargetExportRtValue                               types.String `tfsdk:"vlan_based_route_target_export"`
	EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceDisableCaseDisable   types.Bool   `tfsdk:"vlan_based_ip_local_learning_disable"`
	EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceEnableCaseEnable     types.Bool   `tfsdk:"vlan_based_ip_local_learning_enable"`
	EvpnServiceTypeVlanBasedVlanBasedDefaultGatewayAdvertise                                types.String `tfsdk:"vlan_based_default_gateway_advertise"`
	EvpnServiceTypeVlanBasedVlanBasedReOriginateRouteType5                                  types.Bool   `tfsdk:"vlan_based_re_originate_route_type5"`
}

func (data EVPNInstance) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XE-native:native/l2vpn/Cisco-IOS-XE-l2vpn:evpn_cont/evpn-instance/evpn/instance/instance=%v", data.EvpnInstanceNum.Value)
}

func (data EVPNInstance) toBody() string {
	body := `{"` + helpers.LastElement(data.getPath()) + `":{}}`
	if !data.EvpnInstanceNum.Null && !data.EvpnInstanceNum.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"evpn-instance-num", strconv.FormatInt(data.EvpnInstanceNum.Value, 10))
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceIngressCaseIngress.Null && !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceIngressCaseIngress.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceIngressCaseIngress.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.ingress", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticCaseStatic.Null && !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticCaseStatic.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticCaseStatic.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.static", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticP2mpP2mp.Null && !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticP2mpP2mp.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticP2mpP2mp.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.p2mp", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticMp2mpMp2mp.Null && !data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticMp2mpMp2mp.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticMp2mpMp2mp.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.mp2mp", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedEncapsulation.Null && !data.EvpnServiceTypeVlanBasedVlanBasedEncapsulation.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.encapsulation", data.EvpnServiceTypeVlanBasedVlanBasedEncapsulation.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedAutoRouteTarget_contAutoRouteTargetBoolean.Null && !data.EvpnServiceTypeVlanBasedVlanBasedAutoRouteTarget_contAutoRouteTargetBoolean.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedAutoRouteTarget_contAutoRouteTargetBoolean.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.auto-route-target_cont.auto-route-target-boolean", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedRdRdValue.Null && !data.EvpnServiceTypeVlanBasedVlanBasedRdRdValue.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.rd.rd-value", data.EvpnServiceTypeVlanBasedVlanBasedRdRdValue.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetRtValue.Null && !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetRtValue.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.rt-value", data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetRtValue.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetBothRtValue.Null && !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetBothRtValue.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.both.rt-value", data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetBothRtValue.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetImportRtValue.Null && !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetImportRtValue.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.import.rt-value", data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetImportRtValue.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetExportRtValue.Null && !data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetExportRtValue.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.rt-value", data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetExportRtValue.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceDisableCaseDisable.Null && !data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceDisableCaseDisable.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceDisableCaseDisable.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.ip.local-learning.disable", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceEnableCaseEnable.Null && !data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceEnableCaseEnable.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceEnableCaseEnable.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.ip.local-learning.enable", map[string]string{})
		}
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedDefaultGatewayAdvertise.Null && !data.EvpnServiceTypeVlanBasedVlanBasedDefaultGatewayAdvertise.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.default-gateway.advertise", data.EvpnServiceTypeVlanBasedVlanBasedDefaultGatewayAdvertise.Value)
	}
	if !data.EvpnServiceTypeVlanBasedVlanBasedReOriginateRouteType5.Null && !data.EvpnServiceTypeVlanBasedVlanBasedReOriginateRouteType5.Unknown {
		if data.EvpnServiceTypeVlanBasedVlanBasedReOriginateRouteType5.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.re-originate.route-type5", map[string]string{})
		}
	}
	return body
}

func (data *EVPNInstance) fromBody(res gjson.Result) {
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.ingress"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceIngressCaseIngress.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.static"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticCaseStatic.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.p2mp"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticP2mpP2mp.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.mp2mp"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedReplicationTypeReplicationTypeChoiceStaticMp2mpMp2mp.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.encapsulation"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedEncapsulation.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.auto-route-target_cont.auto-route-target-boolean"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedAutoRouteTarget_contAutoRouteTargetBoolean.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.rd.rd-value"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedRdRdValue.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.rt-value"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetRtValue.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.both.rt-value"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetBothRtValue.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.import.rt-value"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetImportRtValue.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.rt-value"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedRouteTargetExportRtValue.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.ip.local-learning.disable"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceDisableCaseDisable.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.ip.local-learning.enable"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedIpLocalLearningLocalLearningChoiceEnableCaseEnable.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.default-gateway.advertise"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedDefaultGatewayAdvertise.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.re-originate.route-type5"); value.Exists() {
		data.EvpnServiceTypeVlanBasedVlanBasedReOriginateRouteType5.Value = true
	}
}

func (data *EVPNInstance) fromPlan(plan EVPNInstance) {
	data.Device = plan.Device
	data.EvpnInstanceNum.Value = plan.EvpnInstanceNum.Value
}

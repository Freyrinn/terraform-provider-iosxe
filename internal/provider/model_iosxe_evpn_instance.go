// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	"fmt"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/terraform-provider-iosxe/internal/provider/helpers"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

type EVPNInstance struct {
	Device                           types.String `tfsdk:"device"`
	Id                               types.String `tfsdk:"id"`
	EvpnInstanceNum                  types.Int64  `tfsdk:"evpn_instance_num"`
	VlanBasedReplicationTypeIngress  types.Bool   `tfsdk:"vlan_based_replication_type_ingress"`
	VlanBasedReplicationTypeStatic   types.Bool   `tfsdk:"vlan_based_replication_type_static"`
	VlanBasedReplicationTypeP2mp     types.Bool   `tfsdk:"vlan_based_replication_type_p2mp"`
	VlanBasedReplicationTypeMp2mp    types.Bool   `tfsdk:"vlan_based_replication_type_mp2mp"`
	VlanBasedEncapsulation           types.String `tfsdk:"vlan_based_encapsulation"`
	VlanBasedAutoRouteTarget         types.Bool   `tfsdk:"vlan_based_auto_route_target"`
	VlanBasedRd                      types.String `tfsdk:"vlan_based_rd"`
	VlanBasedRouteTarget             types.String `tfsdk:"vlan_based_route_target"`
	VlanBasedRouteTargetBoth         types.String `tfsdk:"vlan_based_route_target_both"`
	VlanBasedRouteTargetImport       types.String `tfsdk:"vlan_based_route_target_import"`
	VlanBasedRouteTargetExport       types.String `tfsdk:"vlan_based_route_target_export"`
	VlanBasedIpLocalLearningDisable  types.Bool   `tfsdk:"vlan_based_ip_local_learning_disable"`
	VlanBasedIpLocalLearningEnable   types.Bool   `tfsdk:"vlan_based_ip_local_learning_enable"`
	VlanBasedDefaultGatewayAdvertise types.String `tfsdk:"vlan_based_default_gateway_advertise"`
	VlanBasedReOriginateRouteType5   types.Bool   `tfsdk:"vlan_based_re_originate_route_type5"`
}

func (data EVPNInstance) getPath() string {
	return fmt.Sprintf("Cisco-IOS-XE-native:native/l2vpn/Cisco-IOS-XE-l2vpn:evpn_cont/evpn-instance/evpn/instance/instance=%v", data.EvpnInstanceNum.Value)
}

func (data EVPNInstance) toBody() string {
	body := `{"` + helpers.LastElement(data.getPath()) + `":{}}`
	if !data.EvpnInstanceNum.Null && !data.EvpnInstanceNum.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"evpn-instance-num", strconv.FormatInt(data.EvpnInstanceNum.Value, 10))
	}
	if !data.VlanBasedReplicationTypeIngress.Null && !data.VlanBasedReplicationTypeIngress.Unknown {
		if data.VlanBasedReplicationTypeIngress.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.ingress", map[string]string{})
		}
	}
	if !data.VlanBasedReplicationTypeStatic.Null && !data.VlanBasedReplicationTypeStatic.Unknown {
		if data.VlanBasedReplicationTypeStatic.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.static", map[string]string{})
		}
	}
	if !data.VlanBasedReplicationTypeP2mp.Null && !data.VlanBasedReplicationTypeP2mp.Unknown {
		if data.VlanBasedReplicationTypeP2mp.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.p2mp", map[string]string{})
		}
	}
	if !data.VlanBasedReplicationTypeMp2mp.Null && !data.VlanBasedReplicationTypeMp2mp.Unknown {
		if data.VlanBasedReplicationTypeMp2mp.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.replication-type.mp2mp", map[string]string{})
		}
	}
	if !data.VlanBasedEncapsulation.Null && !data.VlanBasedEncapsulation.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.encapsulation", data.VlanBasedEncapsulation.Value)
	}
	if !data.VlanBasedAutoRouteTarget.Null && !data.VlanBasedAutoRouteTarget.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.auto-route-target_cont.auto-route-target-boolean", data.VlanBasedAutoRouteTarget.Value)
	}
	if !data.VlanBasedRd.Null && !data.VlanBasedRd.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.rd.rd-value", data.VlanBasedRd.Value)
	}
	if !data.VlanBasedRouteTarget.Null && !data.VlanBasedRouteTarget.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.rt-value", data.VlanBasedRouteTarget.Value)
	}
	if !data.VlanBasedRouteTargetBoth.Null && !data.VlanBasedRouteTargetBoth.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.both.rt-value", data.VlanBasedRouteTargetBoth.Value)
	}
	if !data.VlanBasedRouteTargetImport.Null && !data.VlanBasedRouteTargetImport.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.import.rt-value", data.VlanBasedRouteTargetImport.Value)
	}
	if !data.VlanBasedRouteTargetExport.Null && !data.VlanBasedRouteTargetExport.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.rt-value", data.VlanBasedRouteTargetExport.Value)
	}
	if !data.VlanBasedIpLocalLearningDisable.Null && !data.VlanBasedIpLocalLearningDisable.Unknown {
		if data.VlanBasedIpLocalLearningDisable.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.ip.local-learning.disable", map[string]string{})
		}
	}
	if !data.VlanBasedIpLocalLearningEnable.Null && !data.VlanBasedIpLocalLearningEnable.Unknown {
		if data.VlanBasedIpLocalLearningEnable.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.route-target.export.ip.local-learning.enable", map[string]string{})
		}
	}
	if !data.VlanBasedDefaultGatewayAdvertise.Null && !data.VlanBasedDefaultGatewayAdvertise.Unknown {
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.default-gateway.advertise", data.VlanBasedDefaultGatewayAdvertise.Value)
	}
	if !data.VlanBasedReOriginateRouteType5.Null && !data.VlanBasedReOriginateRouteType5.Unknown {
		if data.VlanBasedReOriginateRouteType5.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"vlan-based.re-originate.route-type5", map[string]string{})
		}
	}
	return body
}

func (data *EVPNInstance) fromBody(res gjson.Result) {
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.ingress"); value.Exists() {
		data.VlanBasedReplicationTypeIngress.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.static"); value.Exists() {
		data.VlanBasedReplicationTypeStatic.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.p2mp"); value.Exists() {
		data.VlanBasedReplicationTypeP2mp.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.replication-type.mp2mp"); value.Exists() {
		data.VlanBasedReplicationTypeMp2mp.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.encapsulation"); value.Exists() {
		data.VlanBasedEncapsulation.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.auto-route-target_cont.auto-route-target-boolean"); value.Exists() {
		data.VlanBasedAutoRouteTarget.Value = value.Bool()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.rd.rd-value"); value.Exists() {
		data.VlanBasedRd.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.rt-value"); value.Exists() {
		data.VlanBasedRouteTarget.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.both.rt-value"); value.Exists() {
		data.VlanBasedRouteTargetBoth.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.import.rt-value"); value.Exists() {
		data.VlanBasedRouteTargetImport.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.rt-value"); value.Exists() {
		data.VlanBasedRouteTargetExport.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.ip.local-learning.disable"); value.Exists() {
		data.VlanBasedIpLocalLearningDisable.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.route-target.export.ip.local-learning.enable"); value.Exists() {
		data.VlanBasedIpLocalLearningEnable.Value = true
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.default-gateway.advertise"); value.Exists() {
		data.VlanBasedDefaultGatewayAdvertise.Value = value.String()
	}
	if value := res.Get(helpers.LastElement(data.getPath()) + "." + "vlan-based.re-originate.route-type5"); value.Exists() {
		data.VlanBasedReOriginateRouteType5.Value = true
	}
}

func (data *EVPNInstance) fromPlan(plan EVPNInstance) {
	data.Device = plan.Device
	data.EvpnInstanceNum.Value = plan.EvpnInstanceNum.Value
}

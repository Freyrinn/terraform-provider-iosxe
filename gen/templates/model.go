//go:build ignore
// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

import (
	{{- if hasId .Attributes }}
	"fmt"
	{{- end}}
	{{- $strconv := false }}{{ range .Attributes}}{{ if or (and (eq .Type "Int64") (ne .Id true) (ne .Reference true)) (eq .Type "List")}}{{ $strconv = true }}{{ end}}{{ end}}
	{{- if $strconv }}
	"strconv"
	{{- end}}

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/netascode/terraform-provider-iosxe/internal/provider/helpers"
	{{- $sjson := false }}{{ range .Attributes}}{{ if ne .Reference true}}{{ $sjson = true }}{{ end}}{{ end}}
	{{- if $sjson }}
	"github.com/tidwall/sjson"
	{{- end}}
	{{- $gjson := false }}{{ range .Attributes}}{{ if and (ne .Reference true) (ne .WriteOnly true)}}{{ $gjson = true }}{{ end}}{{ end}}
	{{- if $gjson }}
	"github.com/tidwall/gjson"
	{{- end}}
)

{{- $name := camelCase .Name}}
type {{camelCase .Name}} struct {
	Device types.String `tfsdk:"device"`
	Id     types.String `tfsdk:"id"`
{{- range .Attributes}}
{{- if eq .Type "List"}}
	{{toGoName .YangName}} []{{$name}}{{toGoName .YangName}} `tfsdk:"{{.TfName}}"`
{{- else}}
	{{toGoName .YangName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
{{- end}}
}

{{- range .Attributes}}
{{- if eq .Type "List"}}
type {{$name}}{{toGoName .YangName}} struct {
{{- range .Attributes}}
	{{toGoName .YangName}} types.{{.Type}} `tfsdk:"{{.TfName}}"`
{{- end}}
}
{{- end}}
{{- end}}

func (data {{camelCase .Name}}) getPath() string {
{{- if hasId .Attributes}}
	return fmt.Sprintf("{{.Path}}"{{range .Attributes}}{{if or (eq .Id true) (eq .Reference true)}}, data.{{toGoName .YangName}}.Value{{end}}{{end}})
{{- else}}
	return "{{.Path}}"
{{- end}}
}

func (data {{camelCase .Name}}) toBody() string {
	body := `{"` + helpers.LastElement(data.getPath()) + `":{}}`
	{{- range .Attributes}}
	{{- if eq .Type "List"}}
	{{- $list := toJsonPath .YangName }}
	body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}", []interface{}{})
	for index, item := range data.{{toGoName .YangName}} {
		{{- range .Attributes}}
		if !item.{{toGoName .YangName}}.Null && !item.{{toGoName .YangName}}.Unknown {
			{{- if eq .Type "Int64"}}
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toJsonPath .YangName}}", strconv.FormatInt(item.{{toGoName .YangName}}.Value, 10))
			{{- else if eq .Type "Bool"}}
			if item.{{toGoName .YangName}}.Value {
				body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toJsonPath .YangName}}", map[string]string{})
			}
			{{- else if eq .Type "String"}}
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{$list}}"+"."+strconv.Itoa(index)+"."+"{{toJsonPath .YangName}}", item.{{toGoName .YangName}}.Value)
			{{- end}}
		}
		{{- end}}
	}
	{{- end}}
	{{- end}}
	{{- range .Attributes}}
	{{- if and (ne .Reference true) (ne .Type "List")}}
	if !data.{{toGoName .YangName}}.Null && !data.{{toGoName .YangName}}.Unknown {
		{{- if eq .Type "Int64"}}
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}", strconv.FormatInt(data.{{toGoName .YangName}}.Value, 10))
		{{- else if eq .Type "Bool"}}
		if data.{{toGoName .YangName}}.Value {
			body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}", map[string]string{})
		}
		{{- else if eq .Type "String"}}
		body, _ = sjson.Set(body, helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}", data.{{toGoName .YangName}}.Value)
		{{- end}}
	}
	{{- end}}
	{{- end}}
	return body
}

func (data *{{camelCase .Name}}) fromBody(res gjson.Result) {
	{{- range .Attributes}}
	{{- if and (ne .Reference true) (ne .Id true) (ne .WriteOnly true)}}
	{{- if eq .Type "Int64"}}
	if value := res.Get(helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}"); value.Exists() {
		data.{{toGoName .YangName}}.Value = value.Int()
	}
	{{- else if eq .Type "Bool"}}
	if value := res.Get(helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}"); value.Exists() {
		data.{{toGoName .YangName}}.Value = true
	}
	{{- else if eq .Type "String"}}
	if value := res.Get(helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}"); value.Exists() {
		data.{{toGoName .YangName}}.Value = value.String()
	}
	{{- else if eq .Type "List"}}
	data.{{toGoName .YangName}} = make([]{{$name}}{{toGoName .YangName}}, 0)
	if value := res.Get(helpers.LastElement(data.getPath())+"."+"{{toJsonPath .YangName}}"); value.Exists() {
		value.ForEach(func(k, v gjson.Result) bool {
			item := {{$name}}{{toGoName .YangName}}{}
			{{- range .Attributes}}
			{{- if ne .WriteOnly true}}
			if cValue := v.Get("{{toJsonPath .YangName}}"); cValue.Exists() {
				{{- if eq .Type "Int64"}}
				item.{{toGoName .YangName}}.Value = cValue.Int()
				{{- else if eq .Type "Bool"}}
				item.{{toGoName .YangName}}.Value = true
				{{- else if eq .Type "String"}}
				item.{{toGoName .YangName}}.Value = cValue.String()
				{{- end}}
			}
			{{- end}}
			{{- end}}
			data.{{toGoName .YangName}} = append(data.{{toGoName .YangName}}, item)
			return true
		})
	}
	{{- end}}
	{{- end}}
	{{- end}}
}

func (data *{{camelCase .Name}}) fromPlan(plan {{camelCase .Name}}) {
	data.Device = plan.Device
	{{- range .Attributes}}
	{{- if or (eq .Reference true) (eq .Id true) (eq .WriteOnly true)}}
	data.{{toGoName .YangName}}.Value = plan.{{toGoName .YangName}}.Value
	{{- end}}
	{{- end}}
}